# Что делает программа

Программа реализует **шифр Вернама**, где **ключ для шифрования** не задаётся вручную, а **генерируется автоматически** с помощью **протокола Диффи–Хеллмана**.
Шифр используется для **побайтного XOR** исходного файла и ключа, что обеспечивает простую и симметричную схему шифрования.

В системе участвуют два пользователя:

* **Алиса** — отправляет сообщение;
* **Боб** — получает сообщение.

---

# Основная идея

> Если Алиса и Боб независимо вычисляют общий секрет $K$ по формулам Диффи–Хеллмана:
>
> $YA = g^{XA} \bmod p, \quad YB = g^{XB} \bmod p$
> 
> то у них получится одинаковое значение:
>
> $K = YB^{XA} \bmod p = YA^{XB} \bmod p$
>
> После этого $K$ можно использовать как **основу для генерации потока байт ключа**, с помощью которого зашифровывается сообщение:
>
> $c_i = m_i \oplus k_i$
>
> где:
>
> * $m_i$ — байт исходного файла,
> * $k_i$ — байт ключа,
> * $c_i$ — байт зашифрованного файла.

---

# 1. Функция `generate_dh_based_key_using_api()`

**Назначение:**
Создать ключ-файл, который будет содержать байтовую последовательность (ключ) длиной, равной указанному файлу.

---

### Алгоритм пошагово:

1. **Генерация параметров Диффи–Хеллмана**

   ```cpp
   auto [p, g, XA, XB] = dh_generate_random_params();
   ```

   * Функция из библиотеки `cryptography.h` подбирает:

     * **p** — большое простое число, вида $p = 2q + 1$;
     * **g** — первообразный корень (основание), для которого $g^q \bmod p \neq 1$;
     * **XA, XB** — случайные секретные числа для Алисы и Боба.
   * Эти параметры гарантируют, что вычисленный общий ключ будет одинаковым у обеих сторон.

---

2. **Вычисление общего секрета**

   ```cpp
   long long K = dh_compute_shared(p, g, XA, XB);
   ```

   * На стороне Алисы:
     [
     YA = g^{XA} \bmod p
     ]
   * На стороне Боба:
     [
     YB = g^{XB} \bmod p
     ]
   * Обе стороны вычисляют общий ключ:
     [
     K = YB^{XA} \bmod p = YA^{XB} \bmod p
     ]
   * Проверяется, что вычисленные значения совпадают — иначе выбрасывается исключение.

   ➤ В нашей реализации обе стороны симулируются локально, поэтому результат всегда одинаков.

---

3. **Преобразование числа K в поток байт**

   ```cpp
   vector<unsigned char> key = expand_secret_to_key(K, key_len);
   ```

   * Число K само по себе слишком короткое — всего 64 бита (8 байт).
     Поэтому его нужно «растянуть» в последовательность длиной `key_len` байт.
   * Для этого используется генератор псевдослучайных чисел `mt19937_64`, инициализированный значением K.
   * Генератор создаёт детерминированный поток байт, одинаковый для Алисы и Боба (ведь у них один и тот же K).

---

4. **Сохранение ключа в файл**

   ```cpp
   ofstream f(key_file, ios::binary);
   f.write((const char*)key.data(), key.size());
   ```

   * Полученные байты записываются в файл `key_file` без форматирования.
   * Этот файл и есть **одноразовый ключ**, который будет использоваться при шифровании.

---

# 2. Функция `vernam_encrypt()`

**Назначение:**
Зашифровать исходный файл, используя байты ключа.

---

### Алгоритм пошагово:

1. **Чтение исходного файла**

   ```cpp
   ifstream fin(input_file, ios::binary);
   fin.seekg(0, ios::end);
   ull orig_size = fin.tellg();
   fin.seekg(0, ios::beg);
   ```

   * Определяется длина исходного файла (`orig_size`).
   * Файл читается побайтно или блоками.

---

2. **Загрузка ключа**

   ```cpp
   vector<unsigned char> key = load_keyfile_bytes(key_file);
   ```

   * Считывается весь ключ из файла.
   * Проверяется, что длина ключа ≥ длине исходного файла.
   * Если ключ короче, программа выбрасывает ошибку.

---

3. **Создание выходного файла и запись заголовка**

   ```cpp
   fout.write("VERN", 4);
   write_le64(fout, orig_size);
   ```

   * Записывается сигнатура `"VERN"` и длина исходного файла (8 байт, Little Endian).
   * Это позволит при расшифровке точно знать, сколько байт восстанавливать.

---

4. **Побайтовое шифрование**

   ```cpp
   out[i] = in[i] ^ key[offset + i];
   ```

   * Каждый байт исходного файла `in[i]` складывается по XOR с соответствующим байтом ключа `key[i]`.
   * Результат записывается в выходной файл.

   ➤ Это и есть шифр Вернама: $c_i = m_i \oplus k_i$


---

# 3. Функция `vernam_decrypt()`

**Назначение:**
Выполнить обратное преобразование — расшифровать зашифрованный файл при помощи того же ключа.

---

### Алгоритм пошагово:

1. **Считывание заголовка**

   ```cpp
   char magic[4];
   fin.read(magic, 4);
   ull orig_size = read_le64(fin);
   ```

   * Проверяется, что первые 4 байта равны `"VERN"`.
   * Извлекается длина исходного файла.

---

2. **Загрузка ключа**

   * Аналогично шифрованию — загружается весь ключ.
   * Проверяется, что ключ не короче исходного размера.

---

3. **Побайтовое дешифрование**

   ```cpp
   plain[i] = cipher[i] ^ key[offset + i];
   ```

   * Так как XOR — операция обратимая: $(m_i \oplus k_i) \oplus k_i = m_i$
   * Следовательно, повторное XOR с тем же ключом восстанавливает исходные данные.
   * После расшифровки пишется ровно `orig_size` байт в выходной файл.

---

# 4. Формат зашифрованного файла

| Смещение | Размер | Описание              |
| -------- | ------ | --------------------- |
| 0        | 4      | Magic — `"VERN"`      |
| 4        | 8      | Исходный размер файла |
| 12       | N байт | Зашифрованные данные  |

---

# 5. Основные принципы работы

| Этап | Действие                  | Формула                                       | Пояснение                                              |
| ---- | ------------------------- | --------------------------------------------- | ------------------------------------------------------ |
| 1    | Генерация параметров DH   | $p = 2q+1$, $g^q \bmod p \neq 1$              | Подбор надёжных параметров                             |
| 2    | Обмен ключами             | $YA = g^{XA} \bmod p,\ YB = g^{XB} \bmod p$   | Алиса и Боб вычисляют открытые ключи                   |
| 3    | Вычисление общего секрета | $K = YB^{XA} \bmod p = YA^{XB} \bmod p$       | Получается одинаковое значение у обеих сторон          |
| 4    | Генерация байтового ключа | $key = \text{expand}(K)$                      | Расширение числа до потока байт                        |
| 5    | Шифрование                | $c_i = m_i \oplus k_i$                        | XOR каждого байта                                      |
| 6    | Расшифрование             | $m_i = c_i \oplus k_i$                        | XOR с тем же ключом восстанавливает исходное сообщение |

---

# 6. Криптографические замечания

* **Шифр Вернама** абсолютно безопасен при выполнении трёх условий:

  1. Ключ полностью случаен.
  2. Ключ используется только один раз.
  3. Длина ключа равна длине сообщения.

* В этой реализации:

  * условие 3 выполняется точно (ключ генерируется под размер файла);
  * 1 и 2 выполняются частично — ключ строится детерминированно из числа K, а не из истинно случайных бит.

---

# 7. Итоговая схема

| Этап | Участник        | Формула                                       | Действие                         |
| ---- | --------------- | --------------------------------------------- | -------------------------------- |
| 1    | **Алиса и Боб** | $p, g, XA, XB$                                | Генерация параметров             |
| 2    | **Алиса ↔ Боб** | $YA = g^{XA} \bmod p,\ YB = g^{XB} \bmod p$   | Обмен открытыми ключами          |
| 3    | **Обе стороны** | $K = YA^{XB} \bmod p$                         | Вычисляют общий секрет           |
| 4    | **Программа**   | $key = expand(K)$                             | Генерация ключа под размер файла |
| 5    | **Алиса**       | $c_i = m_i \oplus k_i$                        | Шифрование                       |
| 6    | **Боб**         | $m_i = c_i \oplus k_i$                        | Расшифрование                    |
