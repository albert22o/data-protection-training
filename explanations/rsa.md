## Что делает программа

Программа реализует шифр **RSA**, в котором участвуют два пользователя:

* **Боб** — получает сообщения. Он создаёт ключи (публичный и закрытый).
* **Алиса** — отправляет сообщение Бобу, используя его **публичный ключ**.

Основная идея RSA:

> Любое число ( m < N ) можно зашифровать и расшифровать по формулам
>
> $e = m^d \mod N, \quad m' = e^c \mod N$
> , где:
>
> * $N = P \times Q$ — произведение двух больших простых чисел,
> * $\varphi = (P-1)(Q-1)$,
> * $d$ — **публичный ключ**,
> * $c$ — **закрытый ключ**, такой, что $c \cdot d \equiv 1 \pmod{\varphi}$.

---

## 1. Функция `generate_rsa_keys()`

**Назначение:** Боб создаёт все параметры RSA — открытые и закрытые ключи.
Эта функция соответствует **этапу инициализации шифра**.

---

### Алгоритм пошагово:

1. **Генерация простых чисел `P` и `Q`**

   ```cpp
   ll P = generate_prime(min_prime, max_prime);
   ll Q = generate_prime(min_prime, max_prime);
   ```

   * Вызывается функция `generate_prime()` из `cryptography.cpp`.
   * Она случайным образом подбирает простое число в заданном диапазоне (например, 1.000–10.000).
   * Проверка простоты выполняется тестом **Миллера–Рабина**.
   * Если $P$ и $Q$ совпали — выбирается новое $Q$.

   ➤ Это базовые «секретные» числа RSA.
   Только Боб их знает.

---

2. **Вычисление $N = P \times Q$**

   ```cpp
   N = P * Q;
   ```

   * $N$ — это **модуль RSA**.
   * Все операции шифрования и расшифрования происходят **по модулю $N$**.
   * $N$ — часть **публичного ключа**. Его знает и Алиса.

---

3. **Вычисление функции Эйлера**

   ```cpp
   phi = (P - 1) * (Q - 1);
   ```

   * $\varphi(N)$ показывает, сколько чисел меньше N взаимно просты с ним.
   * Это используется, чтобы подобрать подходящие ключи ($d$ и $c$).

---

4. **Выбор открытого числа `d`**

   ```cpp
   gcd(d, phi) == 1
   ```

   * $d$ должно быть **меньше $\phi$** и взаимно простым с ним.
   * Это гарантирует существование обратного элемента $c$ по модулю $\phi$.
   * Проверка делается через стандартный `std::gcd`.
   * Если $d$ не подходит — выбирается другое.

---

5. **Вычисление закрытого числа `c`**

   ```cpp
   c = modinv_via_egcd(d, phi);
   ```

   * `modinv_via_egcd()` вызывает **расширенный алгоритм Евклида** (`egcd` из библиотеки cryptography).
   * Он находит числа $x$ и $y$ такие, что:
     
     $d \cdot x + \phi \cdot y = 1$
     
   * Из этого следует, что:
     
     $c = x \mod \phi$
     
     и выполняется:
     
     $c \cdot d \equiv 1 \pmod{\phi}$
     
     ➤ Теперь у нас есть обратная пара:

     * $d$ — публичный ключ
     * $c$ — приватный ключ

---

6. **Сохранение ключей в файл**

   ```cpp
   save_keyfile(key_file, P, Q, d, c);
   ```

   * В файл записываются четыре числа, каждое с новой строки:

     ```
     P
     Q
     d
     c
     ```
   * $P$ и $Q$ — остаются секретом (для контроля).
   * $d$ и $N$ — могут быть переданы другим пользователям (открытый ключ).

---

## 2. Функция `rsa_encrypt()`

**Назначение:** Алиса шифрует файл для Боба, используя его открытый ключ $d$.
Реализует формулу:

$e = m^d \mod N$

---

### Алгоритм пошагово:

1. **Открывается входной файл (исходное сообщение)**
   и создаётся выходной бинарный файл (куда будет записан зашифрованный поток).

2. **Определяются размеры блоков:**

   * Алиса не может зашифровать файл целиком как одно число,
     поэтому делит его на маленькие блоки байт — `plain_block`.

   ```cpp
   plain_block = floor((битовая_длина(N)-1)/8)
   cipher_block = bytes_needed_for_value(N-1)
   ```

   Это значит:

   * каждый блок данных меньше N;
   * каждый шифроблок имеет фиксированную длину в байтах.

---

3. **Создаётся заголовок зашифрованного файла**

   ```
   RSA1 | plain_block | cipher_block | N | orig_size
   ```

   Это нужно, чтобы Боб потом мог знать:

   * размер блоков,
   * длину исходного файла.

---

4. **Обработка каждого блока данных**
   Для каждого блока исходного файла:

   * считываются байты → преобразуются в число $m$;
   * вычисляется $e = m^d \mod N$;
   * результат $e$ записывается в выходной файл в big-endian формате.

   ```cpp
   e = mod_pow(m, d, N);
   ```
---

## 3. Функция `rsa_decrypt()`

**Назначение:** Боб расшифровывает полученное сообщение, используя свой **закрытый ключ $c$**.
Реализует обратное преобразование:

$m' = e^c \mod N$

---

### Алгоритм пошагово:

1. **Боб открывает зашифрованный файл**

   * считывает заголовок: размеры блоков, число $N$, исходный размер файла;
   * проверяет, что $N$ из файла совпадает с $N$ его ключа (чтобы избежать ошибок).

---

2. **Для каждого блока:**

   * считывается зашифрованное число $e$;
   * вычисляется:
     
     $m = e^c \mod N$
     
     при помощи той же `mod_pow`.
   * результат $m$ переводится обратно в байты и записывается в выходной файл.

---

3. **Для последнего блока:**

   * из-за округления размер блока может превышать оригинальную длину файла,
     поэтому из результата берётся только `orig_size` байт.

---

## Итоговая схема взаимодействия

| Этап | Участник  | Формула                                    | Описание                 |
| ---- | --------- | ------------------------------------------ | ------------------------ |
| 1    | **Боб**   | $N=P\cdot Q,\ \varphi=(P-1)(Q-1)$        | Генерирует параметры     |
| 2    | **Боб**   | Выбирает $d$, вычисляет $c = d^{-1} mod φ$ | Формирует ключи          |
| 3    | **Алиса** | $e = m^d \mod N$                         | Шифрует сообщение        |
| 4    | **Боб**   | $m = e^c \mod N$                         | Расшифровывает сообщение |

---

## Основные математические принципы

* RSA основан на **трудности факторизации $N = P×Q$**.
  Зная только $N$ и $d$, Алиса не может найти $c$ без знания $φ$ (а значит, без разложения $N$).
* Умножение по модулю и возведение в степень делают обратное вычисление (из $e$ в $m$) невозможным без $c$.
