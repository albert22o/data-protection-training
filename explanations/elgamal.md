### `void generate_elgamal_keys(const std::string &key_file, ll min_prime, ll max_prime)`

**Цель:** сгенерировать параметры Эль-Гамаля: `p` (простое), `g` (генератор), приватный `c` и публичный `d = g^c mod p`, и сохранить в `key_file`.
**Алгоритм (шаги):**

1. Вызвать `generate_prime(min_prime, max_prime)` — получить `p`.
2. Проверить, что `p > 3`.
3. Найти `g` с `find_primitive_root_using_lib(p)` (см. выше).
4. Сгенерировать приватный `c` случайно из `[2, p-2]`.
5. Вычислить `d = g^c mod p` (использовать `mod_pow` из библиотеки).
6. Записать `p,g,d,c` в keyfile через `save_keyfile`.
   **Важная идея:** приватный `c` должен храниться в секрете; `p`, `g`, `d` — публично.

---

### `void elgamal_encrypt(const std::string &input_file, const std::string &output_file, ull p, ull g, ull d)`

**Цель:** зашифровать целый файл алгоритмом Эль-Гамаля и записать в файл в указанном формате.
**Вход:** `p, g, d` — параметры (d = g^c mod p).
**Алгоритм (детально):**

1. Открыть входной файл `fin` и выходной `fout`.
2. Вычислить `pbits` = сколько бит занимает `p`. На основании этого:

   * `plain_block = max(1, (pbits - 1) / 8)` — максимальное количество байт исходного сообщения, помещающееся в значение `< p`.
   * `cipher_block = bytes_needed_for_value(p-1)` — сколько байт нужно для хранения любого числа < p.
3. Записать заголовок:

   * magic `"ELG1"`, `plain_block` (1 байт), `cipher_block` (1 байт), `p` (8 байт LE), `orig_size` (8 байт LE).
4. Вычитывать файл по `plain_block` байт:

   * Если прочитано меньше `plain_block`, дополнять нулями (чтобы всегда иметь фиксированный m).
   * `m = bytes_to_ull(inbuf)` — преобразовать блок в целое.
   * Проверить `m < p`; иначе ошибка (требуется уменьшить `plain_block` или увеличить `p`).
   * Сгенерировать случайный `k` в `[1, p-2]`.
   * `r = g^k mod p` и `s = d^k mod p`.
   * `e = (m * s) mod p` (с помощью `modmul_u128`).
   * Записать `r` (8 байт LE) и `e` (cipher_block байт BE).
5. Повторять до конца файла.
   **Ключевые моменты и мотивация:**

* Для каждого блока применяется новый `k` — это крипто-правильно (не реиспользовать `k`), иначе информация может быть уязвима.
* Храним `r` для каждого блока, потому что `r` зависит от `k` и нужен при расшифровке.
* `plain_block` подобран так, чтобы `m < p` гарантировалось.
* Используется big-endian для `e` и little-endian для чисел в заголовке/r — важно соблюдать однородность при чтении.

**Сложность:** для каждого блока требуется 2 возведения в степень (g^k, d^k) и одно умножение по модулю. Возведение в степень реализовано в `mod_pow` из библиотеки (обычно быстрая бинарная экспонентация).

---

### `void elgamal_decrypt(const std::string &input_file, const std::string &output_file, ull p, ull c_private)`

**Цель:** восстановить исходный файл из зашифрованного, имея приватный ключ `c_private`.
**Алгоритм (детально):**

1. Открыть вход и выходной файлы.
2. Прочитать заголовок: magic, `plain_block`, `cipher_block`, `p_from_file`, `orig_size`.
3. Проверить, что `p_from_file == p` (иначе — несовпадение ключей/файла).
4. Для каждого блока:

   * читать `r` (8 байт LE),
   * читать `e` (cipher_block байт BE),
   * `s = r^c_private mod p` (через `mod_pow`),
   * найти обратный по модулю `s_inv` к `s` относительно `p`:

     * вызывается `egcd((ll)s, (ll)p)` из библиотеки, получаем `gcd` и коэффициенты, из коэффициентов извлекаем `x` — обратный мод `p` (корректируем, если `x < 0`).
   * `m = (e * s_inv) mod p` (через `modmul_u128`).
   * преобразовать `m` в `plain_block` байт big-endian и записать в выходной файл.
   * если это последний блок — записать только `orig_size - written` байт (т.е. обрезать добавленные нули).
5. Повторять пока не восстановлен весь `orig_size`.
   **Ключевой момент:** обратный элемент `s^{-1}` вычисляется с помощью алгоритма Евклида (через функцию `egcd` из `cryptography`), потому что `p` простое и `s` ≠ 0, обратный гарантирован (если gcd=1).
